---
import {sources} from "../../data/units.json"
import Viewer from "../../components/Viewer/Viewer.astro"
import { TeiBaseStyle, processTei } from 'astro-tei';
import Tei from '../../components/tei/tei'
import slugify from "../../components/helpers/slugify.js";

export function getStaticPaths() {
    return sources.reduce((acc, s) => {
        s.units.map(u => {
            acc.push( {
                params: {
                    source: s.label,
                    unit: slugify(u.label)
                }
            })
        })
        return acc
    }, [])
}

const fetchData = async (url) => {
    const response = await fetch(url)
    let text: string
    if (response.status === 404) {
        text = `<TEI xmlns="http://www.tei-c.org/ns/1.0">TEI data not available yet.</TEI>`
    } else {
        text = await response.text()
    }
    return text
}

const { source, unit } = Astro.params;

// Edition sources are split in units already so can be fetched as discrete XML files.
// Manuscript units, however, needs to be reconstituted from multiple SGA files.

let teiFile: string

if (source !== "MS") {
    // Eventually switch to fv-data.
    // const dataUrl = `https://raw.githubusercontent.com/PghFrankenstein/fv-data/master/variorum-chunks/f${source}_${unit}.xml`
    const dataUrl = `https://raw.githubusercontent.com/FrankensteinVariorum/fv-web2023/main/src/teiFiles/f${source}_${unit}.xml`
    teiFile = await fetchData(dataUrl)
} else {
    // Get URIs for current unit
    const { uris } = sources.filter(s => s.label === source)[0]
        .units.filter(u => slugify(u.label) === unit)[0]
    
    // Download and stitch the URIs
    let content = ""
    for (const uri of uris) {
        const dataUrl = uri.split('#')[0]
        const text = await fetchData(dataUrl)
        content += text.replace(/<\?xml version="1.0" encoding="UTF-8"\?>/gm, '')
    }

    teiFile = `<?xml version="1.0" encoding="UTF-8"?><TEI xmlns="http://www.tei-c.org/ns/1.0">${content}</TEI>`
}

// processTEI() will pre-process the TEI and return a
// `JSDOM` serializable object.
const jdom = processTei(teiFile);
const teiDom = jdom.window.document;

// We need both the TEI in both DOM and string version to
// fully support server and client behaviors.
// The pre-processed DOM object is only available on the server side,
// so the string serialization is necessary for client side operations.
const tei = jdom.serialize();

// We also need a list of element names to register as Custom Elements.
// The list is generated by CETEIcean and is available on the root element.
const elements = teiDom.documentElement.getAttribute("data-elements").split(",");

---

<Viewer>
    <TeiBaseStyle />
    <Tei doc={teiDom} data={tei} elements={elements} client:load />
</Viewer>



