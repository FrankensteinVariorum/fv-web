---
import {sources} from "../../data/units.json";
import Viewer from "../../components/Viewer/Viewer.astro"
import { TeiBaseStyle, processTei } from 'astro-tei';
import Tei from '../../components/tei/tei';
import slugify from "../../components/helpers/slugify.js";

export function getStaticPaths() {
    return sources.reduce((acc, s) => {
        s.units.map(u => {
            acc.push( {
                params: {
                    source: s.label,
                    unit: slugify(u.label)
                }
            })
        })
        return acc
    }, [])
}

const fetchData = async (url) => {
    const response = await fetch(url)
    if (response.status === 404) {
        return null
    }   
    return await response.text()
}

const { source, unit } = Astro.params;

// Get useful data for current unit
const { label, uris, chunks, corresp } = sources.filter(s => s.label === source)[0]
        .units.filter(u => slugify(u.label) === unit)[0]

// Edition sources are split in units already so can be fetched as discrete XML files.
// Manuscript units, however, needs to be reconstituted from multiple SGA files.

let teiFile: string

if (source !== "MS") {
    // Eventually switch to fv-data.
    // const dataUrl = `https://raw.githubusercontent.com/PghFrankenstein/fv-data/master/variorum-chunks/f${source}_${unit}.xml`
    const dataUrl = `https://raw.githubusercontent.com/FrankensteinVariorum/fv-web2023/main/src/teiFiles/f${source}_${unit}.xml`
    const text = await fetchData(dataUrl)
    teiFile = text || `<?xml version="1.0" encoding="UTF-8"?><TEI xmlns="http://www.tei-c.org/ns/1.0">No TEI data found.</TEI>`
} else {
    // Download and stitch the URIs
    let content = ""
    for (const uri of uris) {
        const dataUrl = uri.split('#')[0]
        const text = await fetchData(dataUrl)
        const part = text ? text.replace(/<\?xml version="1.0" encoding="UTF-8"\?>/gm, '') : `No TEI data found.`
        content += part
    }

    teiFile = `<?xml version="1.0" encoding="UTF-8"?><TEI xmlns="http://www.tei-c.org/ns/1.0">${content}</TEI>`
}

// processTEI() will pre-process the TEI and return a
// `JSDOM` serializable object.
const jdom = processTei(teiFile);
const teiDom = jdom.window.document;

// We need both the TEI in both DOM and string version to
// fully support server and client behaviors.
// The pre-processed DOM object is only available on the server side,
// so the string serialization is necessary for client side operations.
const tei = jdom.serialize();

// We also need a list of element names to register as Custom Elements.
// The list is generated by CETEIcean and is available on the root element.
const elements = teiDom.documentElement.getAttribute("data-elements").split(",");

// Finally, we obtain the spine data, which will be used to show variants.
// Each unit will need to consult one or more chunks.
let spineData: string
if (chunks) {
    for (const chunk of chunks) {
        const dataUrl = `https://raw.githubusercontent.com/FrankensteinVariorum/fv-data/master/standoff_Spine/spine_${chunk}.xml`
        const chunkText = await fetchData(dataUrl)
        if (chunkText) {
            spineData += chunkText.replace(/<\?xml version="1.0" encoding="UTF-8"\?>/gm, '')
        }
    }
}

const spine = `<?xml version="1.0" encoding="UTF-8"?><TEI xmlns="http://www.tei-c.org/ns/1.0">${spineData}</TEI>`

---

<Viewer>
    <TeiBaseStyle />
    <Tei data={tei} elements={elements} spine={spine} source={source} client:load />
</Viewer>
