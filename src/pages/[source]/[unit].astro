---
import {sources} from "../../data/units.json"
import Viewer from "../../components/Viewer/Viewer.astro"
import { TeiBaseStyle, processTei } from 'astro-tei';
import Tei from '../../components/tei/tei'

export function getStaticPaths() {
    return sources.reduce((acc, s) => {
        s.units.map(u => {
            acc.push( {
                params: {
                    source: s.label,
                    unit: u.label.replace(" ", "").toLowerCase()
                }
            })
        })
        return acc
    }, [])
}

const { source, unit } = Astro.params;

// Edition sources are split in units already so can be fetched as discrete XML files.
// Manuscript units, however, needs to be reconstituted from multiple SGA files.

let tei

if (source !== "MS") {
    // Eventually switch to fv-data.
    // const dataUrl = `https://raw.githubusercontent.com/PghFrankenstein/fv-data/master/variorum-chunks/f${source}_${unit}.xml`
    const dataUrl = `https://raw.githubusercontent.com/FrankensteinVariorum/fv-web2023/main/src/teiFiles/f${source}_${unit}.xml`
    const response = await fetch(dataUrl)
    const teiFile = await response.text()

    // processTEI() will pre-process the TEI and return a
    // `JSDOM` serializable object.
    const jdom = processTei(teiFile);
    const teiDom = jdom.window.document;

    // We need both the TEI in both DOM and string version to
    // fully support server and client behaviors.
    // The pre-processed DOM object is only available on the server side,
    // so the string serialization is necessary for client side operations.
    tei = jdom.serialize();
}

// We also need a list of element names to register as Custom Elements.
// The list is generated by CETEIcean and is available on the root element.
const elements = teiDom.documentElement.getAttribute("data-elements").split(",");

---

<Viewer>
    <TeiBaseStyle />
    <Tei doc={teiDom} data={tei} elements={elements} client:load />
</Viewer>



