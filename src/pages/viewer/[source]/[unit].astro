---
import {sources} from "../../../data/units.json";
import Viewer from "../../../components/Viewer/Viewer.astro"
import { TeiBaseStyle, processTei } from 'astro-tei';
import Tei from '../../../components/tei/tei';
import slugify from "../../../components/helpers/slugify";


const { source, unit } = Astro.params;

export function getStaticPaths() {
    return sources.reduce((acc, s) => {
        s.units.map(u => {
            acc.push( {
                params: {
                    source: s.label,
                    unit: slugify(u.label)
                }
            })
        })
        return acc
    }, [])
}

const raiseTeiElements = (teiContent) => {
    // Define regex patterns for 'add', 'del', 'del-inner' elements
    const addRegex = /<add .+?ana="start"[^/]+?\/>(.*?)<add ana="end"\/>/g;
    const delRegex = /<del .+?ana="start"[^/]+?\/>(.*?)<del ana="end"\/>/g;
    const delInnerRegex = /<del-INNER ana="start"[^/]+?\/>(.*?)<del-INNER ana="end"\/>/g;
    const mdelRegex = /<mdel ana="start"\/>(.*?)<mdel ana="end"\/>/g;
    const MSpEndRegex = /<milestone unit="tei:p-END"\/>/g;
    const noteRegex = /<note[\s\S]*?ana="start"([^\/]*?)\/>([\s\S]*?)<note ana="end"\/>/gm;
    const metamarkRegex = /<metamark ana="start"[^/]+?\/>(.*?)<metamark ana="end"\/>/g;

    // process elements
    teiContent = teiContent.replace(noteRegex,'<note $1>$2</note>')
    teiContent = teiContent.replace(addRegex, '<add>$1</add>');
    teiContent = teiContent.replace(delRegex, '<del>$1</del>');
    teiContent = teiContent.replace(delInnerRegex, '<del-inner>$1</del-inner>');
    teiContent = teiContent.replace(mdelRegex, '<mdel>$1</mdel>');
    teiContent = teiContent.replace(MSpEndRegex, `<p-end/>`)
    teiContent = teiContent.replace(metamarkRegex, '<metamark>$1</metamark>');

    return teiContent;
};

const fetchData = async (url) => {
    const response = await fetch(url)
    if (response.status === 404) {
        return null
    }
    return await response.text()
}

// Get useful data for current unit
const { label, id, chunks, corresp } = sources.filter(s => s.label === source)[0]
        .units.filter(u => slugify(u.label) === unit)[0]

// Edition sources are split in units already so can be fetched as discrete XML files.
// Manuscript units, however, needs to be reconstituted from multiple SGA files.

let teiFile: string

// if (source !== "MS") {
//     // Eventually switch to fv-data.
    const dataUrl = `https://raw.githubusercontent.com/FrankensteinVariorum/fv-data/master/2023-variorum-chapters/f${source}_${unit}.xml`
    const text = await fetchData(dataUrl)

    // teiFile = processTeiElements(text) || `<?xml version="1.0" encoding="UTF-8"?><TEI xmlns="http://www.tei-c.org/ns/1.0">No TEI data found.</TEI>`
    teiFile = text || `<?xml version="1.0" encoding="UTF-8"?><TEI xmlns="http://www.tei-c.org/ns/1.0">No TEI data found.</TEI>`
    teiFile = raiseTeiElements(teiFile)

// } else {
//     // Download and stitch the URIs
//     let content = ""
//     for (const uri of uris) {
//         const dataUrl = uri.split('#')[0]
//         const text = await fetchData(dataUrl)
//         const part = text ? text.replace(/<\?xml version="1.0" encoding="UTF-8"\?>/gm, '') : `No TEI data found.`
//         content += part
//     }
//
//     teiFile = `<?xml version="1.0" encoding="UTF-8"?><TEI xmlns="http://www.tei-c.org/ns/1.0">${content}</TEI>`
// }

// processTEI() will pre-process the TEI and return a
// `JSDOM` serializable object.
const jdom = processTei(teiFile);
const teiDom = jdom.window.document;

// We need both the TEI in both DOM and string version to
// fully support server and client behaviors.
// The pre-processed DOM object is only available on the server side,
// so the string serialization is necessary for client side operations.
const tei = jdom.serialize();

// We also need a list of element names to register as Custom Elements.
// The list is generated by CETEIcean and is available on the root element.
const elements = teiDom.documentElement.getAttribute("data-elements").split(",");

// Finally, we obtain the spine data, which will be used to show variants.
// Each unit will need to consult one or more chunks.
let spineData: string
if (chunks) {
    for (const chunk of chunks) {
        const chunkLabel = chunk.label
        const dataUrl = `https://raw.githubusercontent.com/FrankensteinVariorum/fv-data/master/2023-standoff_Spine/spine_${chunkLabel}.xml`
        const chunkText = await fetchData(dataUrl)
        if (chunkText) {
            spineData += chunkText.replace(/<\?xml version="1.0" encoding="UTF-8"\?>/gm, '')
        }
    }
}

const spine = `<?xml version="1.0" encoding="UTF-8"?><TEI xmlns="http://www.tei-c.org/ns/1.0">${spineData}</TEI>`

---
<Viewer edition={source}>
    <TeiBaseStyle />
    <Tei style="" data={tei} elements={elements} spine={spine} source={source} unit={unit} client:load />
</Viewer>