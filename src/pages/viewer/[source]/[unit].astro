---
import {sources} from "../../../data/units.json";
import Viewer from "../../../components/Viewer/Viewer.astro"
import { TeiBaseStyle, processTei } from 'astro-tei';
import Tei from '../../../components/tei/tei';
import slugify from "../../../components/helpers/slugify";

const { source, unit } = Astro.params;

export function getStaticPaths() {
    return sources.reduce((acc, s) => {
        s.units.map(u => {
            acc.push( {
                params: {
                    source: s.label,
                    unit: slugify(u.label)
                }
            })
        })
        return acc
    }, [])
}

const raiseTeiElements = (teiContent) => {
    // Define regex patterns
    const MSpEndRegex = /<milestone unit="tei:p-END"\/>/g;
    const delSpanStart = /<delSpan[^>]*spanTo[^>]*\/>/g;
    const delSpanEnd = /<delSpan\sanchor[^>]*\/>/g;

    // process elements
    teiContent = teiContent.replace(delSpanStart, `<span class="delspan">✗—</span>`);
    teiContent = teiContent.replace(delSpanEnd, `<span class="delspan">—✗</span>`);
    teiContent = teiContent.replace(MSpEndRegex, `<p-end/>`);

    return teiContent;
};

const fetchData = async (url) => {
    const response = await fetch(url)
    if (response.status === 404) {
        return null
    }
    return await response.text()
}

// Get useful data for current unit
const { label, id, chunks, corresp } = sources.filter(s => s.label === source)[0]
        .units.filter(u => slugify(u.label) === unit)[0]

// Edition sources are split in units already so can be fetched as discrete XML files.
// Manuscript units, however, needs to be reconstituted from multiple SGA files.

let teiFile: string

// Eventually switch to fv-data.
const dataUrl = `https://raw.githubusercontent.com/FrankensteinVariorum/fv-data/master/2023-variorum-chapters/f${source}_${unit}.xml`
const text = await fetchData(dataUrl)

teiFile = text || `<?xml version="1.0" encoding="UTF-8"?><TEI xmlns="http://www.tei-c.org/ns/1.0">No TEI data found.</TEI>`
teiFile = raiseTeiElements(teiFile)
// console.log(teiFile);
// processTEI() will pre-process the TEI and return a
// `JSDOM` serializable object.
const jdom = processTei(teiFile);
const teiDom = jdom.window.document;

// We need both the TEI in both DOM and string version to
// fully support server and client behaviors.
// The pre-processed DOM object is only available on the server side,
// so the string serialization is necessary for client side operations.
const tei = jdom.serialize();

// We also need a list of element names to register as Custom Elements.
// The list is generated by CETEIcean and is available on the root element.
const elements = teiDom.documentElement.getAttribute("data-elements").split(",");

// Finally, we obtain the spine data, which will be used to show variants.
// Each unit will need to consult one or more chunks.
let spineData: string
if (chunks) {
    for (const chunk of chunks) {
        const chunkLabel = chunk.label
        const dataUrl = `https://raw.githubusercontent.com/FrankensteinVariorum/fv-data/master/2023-standoff_Spine/spine_${chunkLabel}.xml`
        const chunkText = await fetchData(dataUrl)
        if (chunkText) {
            spineData += chunkText.replace(/<\?xml version="1.0" encoding="UTF-8"\?>/gm, '')
        }
    }
}

const spine = `<?xml version="1.0" encoding="UTF-8"?><TEI xmlns="http://www.tei-c.org/ns/1.0">${spineData}</TEI>`


---
<Viewer edition={source}>
    <TeiBaseStyle />
    <Tei style="" data={tei} elements={elements} spine={spine} source={source} unit={unit} client:load />
</Viewer>
